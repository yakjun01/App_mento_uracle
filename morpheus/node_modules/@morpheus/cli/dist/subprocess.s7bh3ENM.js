import * as path from 'path';
import * as os$1 from 'os';
import { c as crossSpawnExports } from './vendor.DEZAgNuY.js';
import * as os from 'node:os';
import { Writable } from 'node:stream';

function getShell() {
    const { shell } = os.userInfo();
    if (shell) {
        return shell;
    }
    if (process.env.SHELL) {
        return process.env.SHELL;
    }
    if (process.platform === 'darwin') {
        return '/bin/bash';
    }
    if (process.platform === 'win32') {
        return process.env.COMSPEC ? process.env.COMSPEC : 'cmd.exe';
    }
    return '/bin/sh';
}
const TERMINAL_INFO = Object.freeze({
    // ci: CI_ENVIRONMENT_VARIABLES_DETECTED.length > 0,
    shell: getShell(),
    tty: Boolean(process.stdin.isTTY && process.stdout.isTTY && process.stderr.isTTY),
    windows: process.platform === 'win32' ||
        Boolean((process.env.OSTYPE && /^(msys|cygwin)$/.test(process.env.OSTYPE)) || (process.env.MSYSTEM && /^MINGW(32|64)$/.test(process.env.MSYSTEM))),
});

/* eslint-disable  */
function createCaseInsensitiveObject() {
    return new Proxy({}, CaseInsensitiveProxyHandler);
}
const CaseInsensitiveProxyHandler = {
    has: (obj, prop) => {
        return conformPropertyKey(prop) in obj;
    },
    get: (obj, prop) => {
        return obj[conformPropertyKey(prop)];
    },
    set: (obj, prop, value) => {
        obj[conformPropertyKey(prop)] = value;
        return true;
    },
    deleteProperty: (obj, prop) => {
        return delete obj[conformPropertyKey(prop)];
    },
};
const conformPropertyKey = (prop) => (typeof prop === 'string' ? prop.toLowerCase() : prop);
function createProcessEnv(...sources) {
    return Object.assign(TERMINAL_INFO.windows ? createCaseInsensitiveObject() : {}, ...sources);
}

/* eslint-disable @typescript-eslint/no-unsafe-call */
const DEFAULT_ALLOC_SIZE = 32;
const DEFAULT_GROW_SIZE = 16;
class WritableStreamBuffer extends Writable {
    constructor(opts) {
        super(opts);
        this._size = 0;
        this.buffer = Buffer.alloc(opts && opts.allocSize ? opts.allocSize : DEFAULT_ALLOC_SIZE);
        this.growSize = opts && opts.growSize ? opts.growSize : DEFAULT_GROW_SIZE;
    }
    get size() {
        return this._size;
    }
    _write(chunk, _encoding, callback) {
        this.buffer = growBufferForAppendedData(this.buffer, this._size, Math.ceil(chunk.length / this.growSize) * this.growSize);
        chunk.copy(this.buffer, this._size, 0);
        this._size += chunk.length;
        callback();
    }
    consume(bytes) {
        bytes = typeof bytes === 'number' ? bytes : this._size;
        const data = Buffer.alloc(bytes);
        this.buffer.copy(data, 0, 0, data.length);
        this.buffer.copy(this.buffer, 0, data.length);
        this._size -= data.length;
        return data;
    }
}
function growBufferForAppendedData(buf, actualsize, appendsize) {
    if (buf.length - actualsize >= appendsize) {
        return buf;
    }
    const newbuffer = Buffer.alloc(buf.length + appendsize);
    buf.copy(newbuffer, 0, 0, actualsize);
    return newbuffer;
}

/* eslint-disable */
const ERROR_COMMAND_NOT_FOUND = 'ERR_SUBPROCESS_COMMAND_NOT_FOUND';
const ERROR_NON_ZERO_EXIT = 'ERR_SUBPROCESS_NON_ZERO_EXIT';
const ERROR_SIGNAL_EXIT = 'ERR_SUBPROCESS_SIGNAL_EXIT';
const TILDE_PATH_REGEX = /^~($|\/|\\)/;
function expandTildePath(p) {
    const h = os$1.homedir();
    return p.replace(TILDE_PATH_REGEX, `${h}$1`);
}
/**
 * Prepare the PATH environment variable for use with subprocesses.
 *
 * If a raw tilde is found in PATH, e.g. `~/.bin`, it is expanded. The raw
 * tilde works in Bash, but not in Node's `child_process` outside of a shell.
 *
 * This is a utility method. You do not need to use it with `Subprocess`.
 *
 * @param path Defaults to `process.env.PATH`
 */
function convertPATH(_path = process.env.PATH || '') {
    return _path.split(path.delimiter).map(expandTildePath).join(path.delimiter);
}
class SubprocessError extends Error {
    constructor(message) {
        super(message);
        this.name = 'SubprocessError';
        this.message = message;
        this.stack = new Error().stack || '';
    }
}
class Subprocess {
    constructor(name, args, options = {}) {
        this.name = name;
        this.args = args;
        const masked = this.maskArg(name);
        if (masked !== name) {
            this.name = masked;
            this.path = name;
        }
        this._options = options;
    }
    get options() {
        const opts = this._options;
        if (!opts.env) {
            opts.env = process.env;
        }
        const env = createProcessEnv(opts.env || {}, {
            PATH: convertPATH(typeof opts.env.PATH === 'string' ? opts.env.PATH : process.env.PATH),
        });
        return { ...opts, env };
    }
    async output() {
        this._options.stdio = 'pipe';
        const promise = this.run();
        const stdoutBuf = new WritableStreamBuffer();
        const stderrBuf = new WritableStreamBuffer();
        const combinedBuf = new WritableStreamBuffer();
        promise.p.stdout?.pipe(stdoutBuf);
        promise.p.stdout?.pipe(combinedBuf);
        promise.p.stderr?.pipe(stderrBuf);
        promise.p.stderr?.pipe(combinedBuf);
        try {
            await promise;
        }
        catch (e) {
            stdoutBuf.end();
            stderrBuf.end();
            e.output = combinedBuf.consume().toString();
            throw e;
        }
        stderrBuf.end();
        combinedBuf.end();
        return stdoutBuf.consume().toString();
    }
    async combinedOutput() {
        this._options.stdio = 'pipe';
        const promise = this.run();
        const buf = new WritableStreamBuffer();
        promise.p.stdout?.pipe(buf);
        promise.p.stderr?.pipe(buf);
        try {
            await promise;
        }
        catch (e) {
            e.output = buf.consume().toString();
            throw e;
        }
        return buf.consume().toString();
    }
    run() {
        const p = this.spawn();
        const promise = new Promise((resolve, reject) => {
            p.on('error', (error) => {
                let err;
                if (error.code === 'ENOENT') {
                    err = new SubprocessError('Command not found.');
                    err.code = ERROR_COMMAND_NOT_FOUND;
                }
                else {
                    err = new SubprocessError('Command error.');
                }
                err.error = error;
                reject(err);
            });
            p.on('close', (code, signal) => {
                let err;
                if (code === 0) {
                    return resolve();
                }
                else if (signal) {
                    err = new SubprocessError('Signal exit from subprocess.');
                    err.code = ERROR_SIGNAL_EXIT;
                    err.signal = signal;
                }
                else if (code) {
                    err = new SubprocessError('Non-zero exit from subprocess.');
                    err.code = ERROR_NON_ZERO_EXIT;
                    err.exitCode = code;
                }
                else {
                    return resolve();
                }
                reject(err);
            });
        });
        Object.defineProperties(promise, {
            p: { value: p },
        });
        return promise;
    }
    spawn() {
        return spawn(this.path ? this.path : this.name, this.args, this.options);
    }
    maskArg(arg) {
        const i = arg.lastIndexOf(path.sep);
        return i >= 0 ? arg.substring(i + 1) : arg;
    }
}
function spawn(command, args = [], options = {}) {
    return crossSpawnExports.spawn(command, [...args], options);
}

export { Subprocess as S };
