import * as path from 'path';
import { l as libExports } from './vendor.DEZAgNuY.js';
import { C as CliConfig, f as fatal } from './index.BBihg1b8.js';
import { n as npmService, s as sdkService } from './SDKService.DqbWTl4i.js';

class AppService {
    constructor(appConfig) {
        this.appConfig = appConfig;
    }
    get cliConfig() {
        return CliConfig.getInstance();
    }
    async loadAppliedPkgs() {
        const srcDir = this.appConfig.appLibrariesDir;
        if (!(await libExports.pathExists(srcDir)))
            return [];
        return await npmService.extractMetaNpmTgzFromDir(srcDir);
    }
    async applyPkgByNames(pkgs) {
        if (pkgs.length === 0)
            return;
        const libraries = await sdkService.selectInstalledLibraries();
        const tools = await sdkService.selectInstalledTools();
        return this.applyPkgs([...libraries, ...tools].filter(({ name }) => pkgs.includes(name)));
    }
    async applyPkgs(libraries) {
        if (libraries.length === 0)
            return;
        const rootDir = this.appConfig.rootDir;
        const packageJson = this.appConfig.packageJson.json;
        const dependencies = { ...packageJson.dependencies };
        const devDependencies = { ...packageJson.devDependencies };
        // const installedLibraries = await this.loadAppliedPkgs();
        const installTasks = libraries.map(({ name, version, filePath }) => {
            // NOTICE : yarn 의 경우 @가 포함되면 설치가 정상적으로 이루어지지 않는다
            const fileName = `${name.split('/').join('-')}-${version}${path.extname(filePath)}`.replace(/@/g, '');
            const dest = path.join(this.appConfig.appLibrariesDir, fileName);
            const dependency = `file:${path.relative(rootDir, dest).replace(/\\\\/g, '/')}`;
            if (this.cliConfig.validateLibraryName(name)) {
                dependencies[name] = dependency;
            }
            else {
                devDependencies[name] = dependency;
            }
            return libExports.copy(filePath, dest);
        });
        await Promise.all(installTasks);
        //  제거하지않는다.
        // const duplicatedLibraries = installedLibraries.filter((installed) => libraries.some((install) => installed.name === install.name));
        // const deleteTasks = duplicatedLibraries.map((v) => remove(v.filePath));
        // await Promise.all([...installTasks, ...deleteTasks]);
        await this.appConfig.packageJson.write({
            ...packageJson,
            dependencies,
            devDependencies,
        });
    }
    /**
     * @param {string[]} libraryNames  e.g ['@morpheus/core','@morpheus/addon-db']
     */
    async unApplyPkgs(libraryNames) {
        if (libraryNames.length === 0)
            return;
        const packageJson = { ...this.appConfig.packageJson.json };
        const installedLibraries = await this.loadAppliedPkgs();
        const uninstallTasks = installedLibraries.filter((v) => libraryNames.some((name) => v.name === name)).map((v) => libExports.remove(v.filePath));
        await Promise.all(uninstallTasks);
        const dependencies = {};
        const devDependencies = {};
        if (packageJson.dependencies) {
            Object.entries(packageJson.dependencies).forEach(([key, value]) => {
                if (libraryNames.includes(key))
                    return;
                dependencies[key] = value;
            });
        }
        if (packageJson.devDependencies) {
            Object.entries(packageJson.devDependencies).forEach(([key, value]) => {
                if (libraryNames.includes(key))
                    return;
                devDependencies[key] = value;
            });
        }
        await this.appConfig.packageJson.write({
            ...packageJson,
            dependencies,
            devDependencies,
        });
    }
    async loadInstalledLibraries() {
        const nodeModulesDir = path.join(this.appConfig.rootDir, 'node_modules');
        const groupDir = path.join(nodeModulesDir, this.cliConfig.LIBRARY_GROUP);
        if (!(await libExports.pathExists(nodeModulesDir)))
            fatal(`${nodeModulesDir} is not exists. you must run 'npm install'.`);
        const files = await libExports.readdir(groupDir, { withFileTypes: true });
        return files
            .filter((f) => (f.isDirectory() || f.isSymbolicLink()) && this.cliConfig.validateLibraryName(this.cliConfig.LIBRARY_GROUP + '/' + f.name))
            .sort((a, b) => this.cliConfig.sortLibraryByName(a.name, b.name))
            .map((f) => path.join(groupDir, f.name));
    }
}

export { AppService as A };
