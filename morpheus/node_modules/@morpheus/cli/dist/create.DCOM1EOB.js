import * as path from 'path';
import { S as Subprocess } from './subprocess.s7bh3ENM.js';
import * as os from 'os';
import { l as libExports } from './vendor.DEZAgNuY.js';
import { s as sdkService, u as unzip } from './SDKService.DqbWTl4i.js';
import { C as CliConfig, P as PackageJson } from './index.BBihg1b8.js';
import { l as licenseService } from './LicenseService.DdVA90Pd.js';
import { A as AssetService, a as AndroidService, I as IosService } from './IosService.CFdTbh92.js';
import { A as AppService } from './AppService.Bv5LpPwI.js';
import { A as AppConfig } from './AppConfig.BjmXUQ7C.js';
import 'node:os';
import 'node:stream';
import 'node:events';
import 'node:child_process';
import 'node:path';
import 'node:fs';
import 'node:process';
import 'util';
import 'stream';
import 'buffer';
import 'events';
import 'fs';
import 'zlib';
import 'tty';
import 'string_decoder';
import 'http';
import 'https';
import 'crypto';
import 'constants';
import 'assert';
import 'child_process';
import 'url';
import 'node:crypto';
import 'node:fs/promises';
import 'node:string_decoder';
import 'domain';
import 'http2';
import 'net';
import 'tls';
import './zip.Urfv9crQ.js';

class ProjectService {
    constructor(rootDir) {
        this.rootDir = rootDir;
    }
    get cliConfig() {
        return CliConfig.getInstance();
    }
    async installTemplate(templates) {
        const installedTemplates = await sdkService.selectInstalledTemplates();
        let extendConfig = {};
        const tasks = installedTemplates
            .filter(({ name }) => templates.includes(name))
            .map(async ({ filePath, morpheusTemplate }) => {
            const tempDir = await libExports.mkdtemp(path.join(os.tmpdir(), 'mcli-'));
            await unzip(filePath, tempDir, ['package.json', 'README.md']);
            const templateDir = path.join(tempDir, 'template');
            const sourceDir = (await libExports.pathExists(templateDir)) ? templateDir : tempDir;
            const files = await libExports.readdir(sourceDir);
            await Promise.all(files.map((f) => {
                const src = path.join(sourceDir, f);
                const dest = path.join(this.rootDir, f);
                return libExports.move(src, dest, { overwrite: true });
            }));
            await libExports.remove(tempDir);
            if (morpheusTemplate && morpheusTemplate.extendConfig) {
                extendConfig = { ...extendConfig, ...morpheusTemplate.extendConfig };
            }
        });
        await Promise.all(tasks);
        return extendConfig;
    }
    async getBasePackageJson() {
        const packageBaseJson = new PackageJson(path.join(this.cliConfig.embedDir, 'package.base.json'));
        await packageBaseJson.read();
        return { ...packageBaseJson.json };
    }
    async writeNpmrc() {
        const { npmRegistryUrl, disabledTLSCerts } = this.cliConfig.extendConfig;
        let content = `${this.cliConfig.LIBRARY_GROUP}:registry=${npmRegistryUrl}`;
        if (disabledTLSCerts) {
            content += '\nstrict-ssl=false \nalways-auth=false';
        }
        await libExports.writeFile(path.join(this.rootDir, '.npmrc'), content, { encoding: 'utf-8' });
    }
}

async function run(projectName, { template, androidAppName, appId, iosAppName, library }) {
    const rootDir = path.join(process.cwd(), projectName);
    const cliConfig = CliConfig.getInstance();
    const appConfig = new AppConfig(rootDir);
    const projectService = new ProjectService(rootDir);
    const assetsService = new AssetService(appConfig.assetDir);
    const androidService = new AndroidService(appConfig.androidDir);
    const iosService = new IosService(appConfig.iosDir);
    const appService = new AppService(appConfig);
    const license = await licenseService.getLicenseByAppId(appId);
    if (await libExports.pathExists(rootDir)) {
        await libExports.remove(rootDir);
    }
    await libExports.ensureDir(rootDir);
    // project 세팅
    const [extendConfig, basePackageJson] = await Promise.all([
        projectService.installTemplate(template),
        projectService.getBasePackageJson(),
        projectService.writeNpmrc(),
    ]);
    if (await libExports.pathExists(appConfig.packageJson.path)) {
        await appConfig.packageJson.read();
        appConfig.packageJson.json.name = projectName;
    }
    else {
        appConfig.packageJson.json = { ...basePackageJson, name: projectName };
    }
    appConfig.config.json = { ...extendConfig, projectName, androidPackageName: license.packageName, androidAppName, applicationId: license.appId };
    const projectTasks = [];
    const iosExists = await libExports.pathExists(appConfig.iosDir);
    // ios 프로젝트에 대한 작업 수행
    if (iosExists && iosAppName) {
        await iosService.applyProjectName(projectName); // projectName을 우선 변경한다.
        projectTasks.push(iosService.applyLicense(license), iosService.applyBundleId(license, projectName), iosService.applyAppName(iosAppName));
        appConfig.config.json = { ...appConfig.config.json, iosAppName, iosBundleId: license.bundleId };
    }
    projectTasks.push(appConfig.config.write(), appConfig.packageJson.write(), assetsService.applyAppLicense(license), androidService.applyLicense(license), androidService.applyPackageName(license), androidService.applyAppName(androidAppName));
    await Promise.all(projectTasks);
    await appService.applyPkgByNames([...library, cliConfig.cliName]);
    const p = new Subprocess(cliConfig.extendConfig.npmClient, ['install'], { cwd: rootDir });
    await p.run();
}

export { run };
