import { w as winstonExports, d as winstonDaily, l as libExports, e as program, O as Option } from './vendor.DEZAgNuY.js';
import * as os from 'os';
import { homedir } from 'os';
import * as path from 'path';
import { fileURLToPath } from 'url';

// Computer OS
var OS;
(function (OS) {
    OS["Unknown"] = "unknown";
    OS["Mac"] = "mac";
    OS["Windows"] = "windows";
    OS["Linux"] = "linux";
})(OS || (OS = {}));
var SDK_TEMPLATE_TYPES;
(function (SDK_TEMPLATE_TYPES) {
    SDK_TEMPLATE_TYPES["ALL"] = "all";
    SDK_TEMPLATE_TYPES["ANDROID"] = "android";
    SDK_TEMPLATE_TYPES["IOS"] = "ios";
    SDK_TEMPLATE_TYPES["WEB"] = "web";
})(SDK_TEMPLATE_TYPES || (SDK_TEMPLATE_TYPES = {}));
var SDK_RESOURCE_DIRS;
(function (SDK_RESOURCE_DIRS) {
    SDK_RESOURCE_DIRS["LIBRARY"] = "libraries";
    SDK_RESOURCE_DIRS["TEMPLATE"] = "templates";
    SDK_RESOURCE_DIRS["TOOL"] = "tools";
})(SDK_RESOURCE_DIRS || (SDK_RESOURCE_DIRS = {}));
var SDK_RESOURCE_TYPES;
(function (SDK_RESOURCE_TYPES) {
    SDK_RESOURCE_TYPES["LIBRARY"] = "library";
    SDK_RESOURCE_TYPES["TEMPLATE"] = "template";
    SDK_RESOURCE_TYPES["TOOL"] = "tool";
})(SDK_RESOURCE_TYPES || (SDK_RESOURCE_TYPES = {}));

class BaseException extends Error {
    constructor(message, code) {
        super(message);
        this.message = message;
        this.code = code;
    }
}
class FatalException extends BaseException {
    constructor(message, exitCode = 1) {
        super(message, 'FATAL');
        this.message = message;
        this.exitCode = exitCode;
    }
}
function fatal(message) {
    throw new FatalException(message);
}
function isSuperAgentError(err) {
    return err && err.response && typeof err.response === 'object';
}

/* eslint-disable @typescript-eslint/restrict-template-expressions */
const { combine, timestamp, printf, errors } = winstonExports.format;
const fatalFormat = winstonExports.format((info) => {
    if (info.code && info.code === 'FATAL') {
        return { ...info, message: `[FATAL] ${info.message}` };
    }
    return info;
});
const httpFormat = winstonExports.format((info) => {
    if (isSuperAgentError(info)) {
        let message = `${info.message}`;
        const response = info.response;
        const request = response.request;
        message += `\n ==> REQUEST ${request.method} ${request.url}`;
        message += `\n ==> RESPONSE [${response.status}] ${response.text}`;
        return {
            ...info,
            message,
        };
    }
    return info;
});
const errorFormat = winstonExports.format((info) => {
    if (typeof info.stack === 'string') {
        return { ...info, message: `${info.message}\n${info.stack}` };
    }
    return info;
});
const consoleFormat = printf(({ level, message }) => {
    return `[${level.toUpperCase()}] ${message}`;
});
const fileFormat = printf(({ level, message, timestamp }) => {
    return `${timestamp} [${level.toUpperCase()}] ${message}`;
});
const logger = winstonExports.createLogger({
    exitOnError: true,
    handleRejections: true,
    format: combine(errors({ stack: true, cause: true }), fatalFormat(), httpFormat(), errorFormat()),
    transports: [
        new winstonExports.transports.Console({ level: 'error', format: combine(consoleFormat) }),
        new winstonDaily({
            level: 'debug',
            format: combine(timestamp(), fileFormat),
            dirname: path.join(os.homedir(), '.morpheus', 'log'),
            filename: '%DATE%.log',
            maxFiles: 2,
        }),
    ],
});

class BaseJson {
    constructor(path) {
        this.path = path;
        this.json = {};
    }
    async read() {
        this.json = (await libExports.readJSON(this.path));
    }
    async write(json) {
        if (json)
            this.json = json;
        await libExports.writeJSON(this.path, this.json, { encoding: 'utf-8', spaces: 2 });
    }
}

class PackageJson extends BaseJson {
}

class CliExtendJson extends BaseJson {
    getDefaultValue() {
        return {
            npmRegistryUrl: 'https://packages.morpheus.kr/repository/npm-release',
            npmClient: 'npm',
            template: {
                npmRegistryUrl: 'https://packages.morpheus.kr/repository/npm-release',
                npmPackageScope: '@morpheus-template',
            },
        };
    }
    async read() {
        if (await libExports.pathExists(this.path)) {
            await super.read();
        }
        else {
            await this.write(this.getDefaultValue());
        }
    }
}

class CliConfig {
    constructor() {
        this.LIBRARY_GROUP = '@morpheus';
        this.rootDir = path.join(path.dirname(fileURLToPath(import.meta.url)), '..');
        this.dataDir = path.join(homedir(), '.morpheus');
        this.embedDir = path.join(this.rootDir, 'embed');
        this._packageJson = new PackageJson(path.join(this.rootDir, 'package.json'));
        this._extendConfig = new CliExtendJson(path.join(this.dataDir, 'config.json'));
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new CliConfig();
        }
        return this.instance;
    }
    get packageJson() {
        return this._packageJson.json;
    }
    get extendConfig() {
        return this._extendConfig.json;
    }
    get cliName() {
        return this._packageJson.json.name;
    }
    validateLibraryName(name) {
        const [group, _name] = name.split('/');
        if (group === this.LIBRARY_GROUP && typeof _name === 'string') {
            const [prefix] = _name.split('-');
            return ['core', 'addon', 'plugin', 'trd'].includes(prefix);
        }
        return false;
    }
    validateTemplateName(name) {
        return name.startsWith(`${this.extendConfig.template.npmPackageScope}/`);
    }
    sortLibraryByName(a, b) {
        return this.transferSortNumByLibrary(a) - this.transferSortNumByLibrary(b);
    }
    transferSortNumByLibrary(name) {
        if (name.includes('core'))
            return 0;
        if (name.includes('addon'))
            return 1;
        if (name.includes('plugin'))
            return 2;
        if (name.includes('trd'))
            return 4;
        return 5;
    }
    async init() {
        await this._packageJson.read();
        await this._extendConfig.read();
    }
}

async function setup() {
    const config = CliConfig.getInstance();
    await config.init();
    return config;
}

function wrapAction(action) {
    return async (...args) => {
        // eslint-disable-next-line no-useless-catch
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            await action(...args);
        }
        catch (e) {
            throw e;
        }
    };
}

process.on('unhandledRejection', (error) => {
    logger.error(error);
});
async function run() {
    try {
        const config = await setup();
        runProgram(config);
    }
    catch (e) {
        process.exitCode = 1;
        if (e instanceof Error) {
            logger.error(e.message);
        }
        else {
            logger.error(String(e));
        }
    }
}
function runProgram(config) {
    program.name('morpheus').description('Development Morpheus Tools').version(config.packageJson.version);
    registServiceCommand();
    program
        .command('sync')
        .summary('설치된 모피어스 리소스를 플랫폼 별로 동기화합니다.')
        .description('npm install에 실행되어야합니다.')
        .action(async () => {
        const { run } = await import('./sync.yjuRhOQQ.js');
        await run();
    });
    program.arguments('[command]').action(wrapAction((cmd) => {
        if (typeof cmd === 'undefined') {
            program.outputHelp();
        }
        else {
            fatal(`Unknown command: ${cmd}`);
        }
    }));
    program.parse(process.argv);
}
function registServiceCommand() {
    const service = program.command('service', { hidden: true });
    const sdk = service.command('sdk');
    const license = service.command('license');
    const pkg = service.command('pkg');
    service
        .command('create')
        .summary('모피어스 프로젝트 생성')
        .addOption(new Option('--template <templates...>', '적용할 템플릿').makeOptionMandatory())
        .addOption(new Option('--library <libraries...>', '적용할 라이브러리').makeOptionMandatory())
        .addOption(new Option('--app-id <appId>', '라이선스 앱ID').makeOptionMandatory())
        .addOption(new Option('--android-app-name <name>', 'Android 앱명').makeOptionMandatory())
        .addOption(new Option('--ios-app-name <name>', 'iOS 앱명'))
        .argument('<projectName>', '프로젝트 명')
        .action(async (projectName, opts) => {
        const { run } = await import('./create.DCOM1EOB.js');
        await run(projectName, opts);
    });
    sdk
        .command('list')
        .summary('M-SDK 리소스 목록 조회')
        .option('--latest', '최신 리소스 정보를 조회합니다.(online)', false)
        .action(async (opts) => {
        const { run } = await import('./list.BgABu9PP.js');
        await run(opts);
    });
    sdk
        .command('install')
        .summary('M-SDK 리소스 설치')
        .addOption(new Option('--type <resourcetype>', 'Resource type; library or template')
        .choices([SDK_RESOURCE_TYPES.LIBRARY, SDK_RESOURCE_TYPES.TEMPLATE, SDK_RESOURCE_TYPES.TOOL])
        .makeOptionMandatory())
        .argument('<pkgs...>', 'e.g @morpheus/core @morpheus/addon-db')
        .action(async (pkgs, { type }) => {
        const { run } = await import('./install.BS-Y475V.js');
        await run(pkgs, { type });
    });
    sdk
        .command('uninstall')
        .summary('M-SDK 리소스 삭제')
        .addOption(new Option('--type <resourcetype>', 'Resource type; library or template')
        .choices([SDK_RESOURCE_TYPES.LIBRARY, SDK_RESOURCE_TYPES.TEMPLATE, SDK_RESOURCE_TYPES.TOOL])
        .makeOptionMandatory())
        .argument('<pkgs...>', 'e.g @morpheus/core @morpheus/addon-db')
        .action(async (pkgs, { type }) => {
        const { run } = await import('./uninstall.C407qUnU.js');
        await run(pkgs, { type });
    });
    sdk
        .command('import')
        .summary('M-SDK 리소스 가져오기')
        .addOption(new Option('--parsing', 'parsing resources zip file').default(false))
        .addOption(new Option('--targets <targets...>', '가져오기할 리소스 타겟들').default([]))
        .argument('<zipFile>', '가져올 압축 파일 경로')
        .action(async (zipFile, { parsing, targets }) => {
        const { run } = await import('./import.CBAieYVT.js');
        await run(zipFile, { parsing, targets });
    });
    sdk
        .command('export')
        .summary('M-SDK 리소스 내보내기')
        .addOption(new Option('--targets <targets...>', '내보내기할 리소스 타겟들').makeOptionMandatory())
        .argument('<zipFile>', '내보내기할 압축 파일 경로')
        .action(async (zipFile, { targets }) => {
        const { run } = await import('./export.EAx7SkSv.js');
        await run(zipFile, { targets });
    });
    license
        .command('add')
        .summary('모피어스 라이선스 등록')
        .argument('<license>', '라이센스 파일 경로')
        .action(async (license) => {
        const { run } = await import('./add.CLALAk4B.js');
        await run(license);
    });
    license
        .command('list')
        .summary('모피어스 라이선스 목록')
        .action(async () => {
        const { run } = await import('./list.DQHXyg18.js');
        await run();
    });
    license
        .command('remove')
        .summary('모피어스 라이선스 삭제')
        .argument('<appId>', '앱 아이디')
        .action(async (appId) => {
        const { run } = await import('./remove.DY6D0788.js');
        await run(appId);
    });
    license
        .command('apply')
        .summary('모피어스 라이선스 적용')
        .argument('<appId>', '앱 아이디')
        .action(async (appId) => {
        const { run } = await import('./apply.CeSU760_.js');
        await run(appId);
    });
    pkg
        .command('apply')
        .summary('모피어스 프로젝트 내 패키지 적용')
        .argument('<pkgs...>', '설치할 패키지 명')
        .action(async (pkgs) => {
        const { run } = await import('./apply.C8aUccRa.js');
        await run(pkgs);
    });
    pkg
        .command('unapply')
        .summary('모피어스 프로젝트 내 패키지 해제')
        .argument('<pkgs...>', '설치할 패키지 명')
        .action(async (pkgs) => {
        const { run } = await import('./unapply.DBwI28GE.js');
        await run(pkgs);
    });
    pkg
        .command('list')
        .summary('모피어스 프로젝트 내 패키지 목록')
        .option('--sdk', '적용 가능한 패키지 목록을 M-SDK로부터 불러옵니다.', false)
        .action(async ({ sdk }) => {
        const { run } = await import('./list.bC8hgT8W.js');
        await run({ sdk });
    });
}

export { BaseException as B, CliConfig as C, PackageJson as P, SDK_RESOURCE_TYPES as S, BaseJson as a, SDK_RESOURCE_DIRS as b, SDK_TEMPLATE_TYPES as c, runProgram as d, fatal as f, run as r };
