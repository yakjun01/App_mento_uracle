import * as os from 'os';
import * as path from 'path';
import { b as superagent, l as libExports, t as tarStreamExports } from './vendor.DEZAgNuY.js';
import { C as CliConfig, b as SDK_RESOURCE_DIRS, c as SDK_TEMPLATE_TYPES } from './index.BBihg1b8.js';
import { u as unzip$1, z as zip } from './zip.Urfv9crQ.js';
import * as zlib from 'zlib';

var ContentType;
(function (ContentType) {
    ContentType["JSON"] = "application/json";
    ContentType["FORM_URLENCODED"] = "application/x-www-form-urlencoded";
    ContentType["HTML"] = "text/html";
})(ContentType || (ContentType = {}));
function createRequest(method, url) {
    const config = CliConfig.getInstance();
    const req = superagent(method, url);
    if (config.extendConfig.disabledTLSCerts) {
        req.disableTLSCerts();
    }
    req.set('User-Agent', `node/superagent/Morpheus CLI ${config.packageJson.version}`).redirects(25);
    // if (ssl) {
    //   const cafiles = conform(ssl.cafile)
    //   const certfiles = conform(ssl.certfile)
    //   const keyfiles = conform(ssl.keyfile)
    //   if (cafiles.length > 0) {
    //     req.ca(
    //       await Promise.all(cafiles.map((p) => readFile(p, { encoding: 'utf8' })))
    //     )
    //   }
    //   if (certfiles.length > 0) {
    //     req.cert(
    //       await Promise.all(
    //         certfiles.map((p) => readFile(p, { encoding: 'utf8' }))
    //       )
    //     )
    //   }
    //   if (keyfiles.length > 0) {
    //     req.key(
    //       await Promise.all(
    //         keyfiles.map((p) => readFile(p, { encoding: 'utf8' }))
    //       )
    //     )
    //   }
    // }
    return req;
}
/**
 * Initiate a request, downloading the contents to a writable stream.
 *
 * @param req The request to download to the writable stream.
 * @param ws Must be a dedicated writable stream that calls the 'close' event.
 * @return Promise<void>
 */
async function download(req, ws, { progress } = {}) {
    return new Promise((resolve, reject) => {
        req
            .on('response', (res) => {
            if (res.status !== 200) {
                reject(new Error(`Encountered bad status code (${res.status}) for ${req.url}\n` +
                    `This could mean the server is experiencing difficulties right now--please try again later.`));
            }
            if (progress) {
                let loaded = 0;
                const total = Number(res.header['content-length']);
                res.on('data', (chunk) => {
                    loaded += chunk.length;
                    progress(loaded, total);
                });
            }
        })
            .on('error', (err) => {
            if (err.code === 'ECONNABORTED') {
                reject(new Error(`Timeout of ${err.timeout}ms reached for ${req.url}`));
            }
            else {
                reject(err);
            }
        });
        ws.on('close', resolve);
        req.pipe(ws);
    });
}

function unzip(source, dest, ignoreFiles) {
    return unzipFromStream(libExports.createReadStream(source), dest, ignoreFiles);
}
function unzipFromStream(stream, dest, ignoreFiles = []) {
    return new Promise((resolve, reject) => {
        const extract = tarStreamExports.extract();
        extract.on('entry', async function (header, stream, next) {
            try {
                // window도 unzip시 경로는 /로 구분한다.
                const names = header.name.split('/');
                names.shift(); // 루트 폴더 제거
                const targetPath = path.join(dest, ...names);
                const targetFileName = names.pop(); // file name일수도 아닐수도.
                const targetDir = path.join(dest, ...names);
                let ws = null;
                switch (header.type) {
                    case 'directory':
                        await libExports.ensureDir(targetPath);
                        break;
                    case 'file':
                        if (ignoreFiles.includes([...names, targetFileName].join('/'))) {
                            break;
                        }
                        await libExports.ensureDir(targetDir);
                        ws = libExports.createWriteStream(targetPath);
                        stream.pipe(ws);
                        break;
                    case 'symlink':
                        // ignore symlinks since they will not work on windows
                        break;
                    default:
                        throw new Error(`unknwon file type ${header.type}`);
                }
                if (ws) {
                    ws.on('close', next);
                }
                else {
                    stream.on('end', next);
                }
                stream.resume(); // just auto drain the stream
            }
            catch (e) {
                reject(e);
            }
        });
        extract.on('finish', resolve);
        extract.on('error', reject);
        stream.pipe(zlib.createGunzip()).pipe(extract);
    });
}
function extractFiles(source, files) {
    const readStream = libExports.createReadStream(source);
    return extractFilesFromStraem(readStream, files);
}
function extractFilesFromStraem(readStream, files) {
    return new Promise((resolve, reject) => {
        const result = new Array(files.length).fill('');
        const extract = tarStreamExports.extract();
        extract.on('entry', (header, stream, next) => {
            try {
                const names = header.name.split('/');
                names[0] = ''; // 루트 폴더 제거
                // const targetFileName = names.pop() as string; // file name일수도 아닐수도.
                const filePath = names.join('/');
                const exist = files.indexOf(filePath);
                switch (header.type) {
                    case 'file':
                        if (exist > -1) {
                            stream.on('data', (chunk) => {
                                result[exist] += chunk.toString();
                            });
                        }
                        break;
                    default:
                        throw new Error(`unknwon file type ${header.type}`);
                }
                stream.on('end', next);
                stream.resume(); // just auto drain the stream
            }
            catch (e) {
                reject(e);
            }
        });
        extract.on('finish', () => {
            resolve(result);
        });
        extract.on('error', reject);
        readStream.pipe(zlib.createGunzip()).pipe(extract);
    });
}

class NpmService {
    async fetchNpmPackagesByScope(registryUrl, scope) {
        const res = await createRequest('GET', `${registryUrl}/-/v1/search?size=250&text=${scope}`);
        const pkgs = [];
        res.body.objects.forEach(({ package: pkg }) => {
            const { name, version, description } = pkg;
            if (name.includes('/')) {
                // 일부 다른 그룹명도 검색에 포함되기 때문에 그룹명을 확인하고 불러온다.
                if (name.startsWith(`${scope}/`)) {
                    pkgs.push({ name, version, description });
                }
            }
            else {
                // nexus는 검색시 그룹명이 누락되어 내려온다.
                pkgs.push({ name: `${scope}/${name}`, version, description });
            }
        });
        return pkgs;
    }
    async fetchNpmPackage(registryUrl, pkgName) {
        const res = await createRequest('GET', `${registryUrl}/${pkgName}`);
        const body = res.body;
        const latest = body['dist-tags']['latest'];
        const { name, description, readme: history, version, dist: { tarball }, morpheus, morpheusTemplate, } = body['versions'][latest];
        return { name, description, history, version, tarball, morpheus, morpheusTemplate };
    }
    async extractMetaNpmTgzFromDir(sourceDir) {
        if (!(await libExports.pathExists(sourceDir)))
            return [];
        const files = await libExports.readdir(sourceDir, { withFileTypes: true });
        const promises = files
            .filter((f) => f.isFile() && f.name.endsWith('.tgz'))
            .map(async (f) => {
            const target = path.join(sourceDir, f.name);
            const metas = await extractFiles(target, ['/package.json', '/README.md']);
            return [target, ...metas];
        });
        const metaFiles = await Promise.all(promises);
        const pkgs = metaFiles.map(([filePath, packageJsonStr, history]) => {
            const { name, description, version, morpheus, morpheusTemplate } = JSON.parse(packageJsonStr);
            return { name, description, history, version, filePath, morpheus, morpheusTemplate };
        });
        /**
         * 중복되는 tgz 파일이 존재하는 경우를 방어하기위한 코드
         * 버전이 더 높은걸 리턴하도록 처리
         */
        const map = new Map();
        pkgs.forEach((pkg) => {
            const exist = map.get(pkg.name);
            if (exist && exist.version.replace(/\D/g, '') > pkg.version.replace(/\D/g, '')) {
                // 존재하는 pkg의 버전이 더 높은 경우에는 할당하지 않는다.
                return;
            }
            // 그외에는 set
            map.set(pkg.name, pkg);
        });
        return [...map.values()];
    }
    async downloadNpmTgz(pkgs, destDir) {
        const tempDir = await libExports.mkdtemp(path.join(os.tmpdir(), 'mcli-'));
        try {
            const downloadTasks = pkgs.map(async ({ tarball, name }) => {
                const req = createRequest('GET', tarball);
                const fileName = `${name.split('/').join('-').replace(/@/g, '')}.tgz`;
                const dest = path.join(tempDir, fileName);
                const ws = libExports.createWriteStream(dest);
                await download(req, ws);
                return { fileName, filePath: dest };
            });
            const downloads = await Promise.allSettled(downloadTasks);
            await libExports.ensureDir(destDir);
            const moveTasks = downloads
                .filter((item) => item.status === 'fulfilled')
                .map(({ value: { fileName, filePath } }) => {
                const dest = path.join(destDir, fileName);
                return libExports.move(filePath, dest, { overwrite: true });
            });
            await Promise.allSettled(moveTasks);
        }
        finally {
            // cleanup
            await libExports.remove(tempDir);
        }
    }
    compareVersions(v1, v2) {
        const parse = (v) => {
            const [main, pre] = v.split('-');
            const [maj, min, pat] = main.split('.').map(Number);
            return { maj, min, pat, pre };
        };
        const p1 = parse(v1);
        const p2 = parse(v2);
        if (p1.maj !== p2.maj)
            return p1.maj - p2.maj;
        if (p1.min !== p2.min)
            return p1.min - p2.min;
        if (p1.pat !== p2.pat)
            return p1.pat - p2.pat;
        if (!p1.pre && p2.pre)
            return -1;
        if (p1.pre && !p2.pre)
            return 1;
        if (p1.pre && p2.pre)
            return p1.pre.localeCompare(p2.pre);
        return 0;
    }
    uniqPkg(arr) {
        const map = new Map();
        arr.forEach((item) => {
            const exist = map.get(item.name);
            if (exist) {
                const latest = [item, exist].sort((a, b) => this.compareVersions(a.version, b.version)).pop();
                map.set(latest.name, latest);
            }
            else {
                map.set(item.name, item);
            }
        });
        return Array.from(map.values());
    }
}
const npmService = new NpmService();

const SDK_TEMPLATE_TYPE_ARR = [SDK_TEMPLATE_TYPES.ALL, SDK_TEMPLATE_TYPES.ANDROID, SDK_TEMPLATE_TYPES.IOS, SDK_TEMPLATE_TYPES.WEB];
class SDKService {
    get cliConfig() {
        return CliConfig.getInstance();
    }
    get resourcesDir() {
        return path.join(this.cliConfig.dataDir, 'resources');
    }
    get templatesDir() {
        return path.join(this.resourcesDir, SDK_RESOURCE_DIRS.TEMPLATE);
    }
    get librariesDir() {
        return path.join(this.resourcesDir, SDK_RESOURCE_DIRS.LIBRARY);
    }
    get toolsDir() {
        return path.join(this.resourcesDir, SDK_RESOURCE_DIRS.TOOL);
    }
    async selectLatestLibraries() {
        const npmRegistryUrl = this.cliConfig.extendConfig.npmRegistryUrl;
        const pkgs = await npmService.fetchNpmPackagesByScope(npmRegistryUrl, this.cliConfig.LIBRARY_GROUP);
        const promises = pkgs
            .filter(({ name }) => this.cliConfig.validateLibraryName(name))
            .map(async ({ name }) => {
            return npmService.fetchNpmPackage(npmRegistryUrl, name);
        });
        const libraries = await Promise.all(promises);
        return libraries.sort((a, b) => this.cliConfig.sortLibraryByName(a.name, b.name));
    }
    async selectLatestTemplates() {
        const templateConfig = this.cliConfig.extendConfig.template;
        const pkgs = await npmService.fetchNpmPackagesByScope(templateConfig.npmRegistryUrl, templateConfig.npmPackageScope);
        const promises = pkgs.map(async ({ name }) => {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { morpheus, ...item } = await npmService.fetchNpmPackage(templateConfig.npmRegistryUrl, name);
            const { morpheusTemplate } = item;
            if (morpheusTemplate && morpheusTemplate.type && SDK_TEMPLATE_TYPE_ARR.includes(morpheusTemplate.type)) {
                return { ...item, type: morpheusTemplate.type };
            }
            return {
                ...item,
                type: SDK_TEMPLATE_TYPES.ALL,
            };
        });
        return await Promise.all(promises);
    }
    async selectLatestCli() {
        return await npmService.fetchNpmPackage(this.cliConfig.extendConfig.npmRegistryUrl, this.cliConfig.cliName);
    }
    async selectLatestTools() {
        return [await this.selectLatestCli()];
    }
    async selectInstalledLibraries() {
        const libraries = await npmService.extractMetaNpmTgzFromDir(this.librariesDir);
        return npmService.uniqPkg(libraries).sort((a, b) => this.cliConfig.sortLibraryByName(a.name, b.name));
    }
    async selectInstalledTools() {
        const tools = await npmService.extractMetaNpmTgzFromDir(this.toolsDir);
        return npmService.uniqPkg(tools);
    }
    async selectInstalledTemplates() {
        const pkgs = await npmService.extractMetaNpmTgzFromDir(this.templatesDir);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const templates = pkgs.map(({ morpheus, ...item }) => {
            const { morpheusTemplate } = item;
            if (morpheusTemplate && morpheusTemplate.type && SDK_TEMPLATE_TYPE_ARR.includes(morpheusTemplate.type)) {
                return { ...item, type: morpheusTemplate.type };
            }
            return {
                ...item,
                type: SDK_TEMPLATE_TYPES.ALL,
            };
        });
        return npmService.uniqPkg(templates);
    }
    /**
     * @param {string[]} libraries  e.g ['@morheus/core', '@morpheus/addon-db']
     */
    async installLatestLibraries(libraries) {
        const promises = await Promise.allSettled(libraries.map(async (name) => {
            return await npmService.fetchNpmPackage(this.cliConfig.extendConfig.npmRegistryUrl, name);
        }));
        const pkgs = promises
            .filter((item) => item.status === 'fulfilled')
            .map(({ value }) => value);
        await npmService.downloadNpmTgz(pkgs, this.librariesDir);
    }
    /**
     * @param {string[]} tools  e.g ['@morheus/cli']
     */
    async installLatestTools(tools) {
        const tasks = tools.reduce((acc, name) => {
            if (name === this.cliConfig.cliName) {
                acc.push(this.selectLatestCli());
            }
            return acc;
        }, []);
        const pkgs = await Promise.all(tasks);
        await npmService.downloadNpmTgz(pkgs, this.toolsDir);
    }
    /**
     * @param {string[]} templates  e.g ['@morpheus-template/android-java', '@morpheus-template/ios-objc']
     */
    async installLatestTemplates(templates) {
        const promises = await Promise.allSettled(templates.map(async (name) => {
            return await npmService.fetchNpmPackage(this.cliConfig.extendConfig.template.npmRegistryUrl, name);
        }));
        const pkgs = promises
            .filter((item) => item.status === 'fulfilled')
            .map(({ value }) => value);
        await npmService.downloadNpmTgz(pkgs, this.templatesDir);
    }
    /**
     * @param {string[]} pkgs  e.g ['@morpheus/core', '@morpheus-template/ios-objc']
     */
    async uninstallLibraries(pkgs) {
        const installedPkgs = await this.selectInstalledLibraries();
        const removePkgTasks = installedPkgs.filter(({ name }) => pkgs.includes(name)).map(({ filePath }) => libExports.remove(filePath));
        await Promise.allSettled(removePkgTasks);
    }
    /**
     * @param {string[]} pkgs  e.g ['@morpheus/core', '@morpheus-template/ios-objc']
     */
    async uninstallTemplates(pkgs) {
        const installedPkgs = await this.selectInstalledTemplates();
        const removePkgTasks = installedPkgs.filter(({ name }) => pkgs.includes(name)).map(({ filePath }) => libExports.remove(filePath));
        await Promise.allSettled(removePkgTasks);
    }
    /**
     * @param {string[]} pkgs  e.g ['@morpheus/core', '@morpheus-template/ios-objc']
     */
    async uninstallTools(pkgs) {
        const installedPkgs = await this.selectInstalledTools();
        const removePkgTasks = installedPkgs.filter(({ name }) => pkgs.includes(name)).map(({ filePath }) => libExports.remove(filePath));
        await Promise.allSettled(removePkgTasks);
    }
    async importResources(zipFile, targets) {
        const tempDir = await libExports.mkdtemp(path.join(os.tmpdir(), 'mcli-'));
        const outputDir = path.join(tempDir, 'output');
        await unzip$1(zipFile, tempDir, 'output');
        const types = [SDK_RESOURCE_DIRS.LIBRARY, SDK_RESOURCE_DIRS.TEMPLATE, SDK_RESOURCE_DIRS.TOOL];
        const parseTasks = types.map((type) => npmService.extractMetaNpmTgzFromDir(path.join(outputDir, type)));
        const [libraries, templates, tools] = await Promise.all(parseTasks);
        const resources = { libraries, templates, tools };
        const tasks = types.reduce((acc, type) => {
            const _tasks = resources[type]
                .filter(({ name }) => targets.includes(name))
                .map(async ({ filePath, name }) => {
                const fileName = `${name.split('/').join('-').replace(/@/g, '')}.tgz`;
                const dest = path.join(this.resourcesDir, type, fileName);
                await libExports.move(filePath, dest, { overwrite: true });
            });
            return [...acc, ..._tasks];
        }, []);
        await Promise.all(tasks);
        await libExports.remove(tempDir);
    }
    async parsingZip(zipFile) {
        const tempDir = await libExports.mkdtemp(path.join(os.tmpdir(), 'mcli-'));
        const outputDir = path.join(tempDir, 'output');
        await unzip$1(zipFile, tempDir, 'output');
        const types = [SDK_RESOURCE_DIRS.LIBRARY, SDK_RESOURCE_DIRS.TEMPLATE, SDK_RESOURCE_DIRS.TOOL];
        const tasks = types.map((type) => npmService.extractMetaNpmTgzFromDir(path.join(outputDir, type)));
        const [libraries, templates, tools] = await Promise.all(tasks);
        await libExports.remove(tempDir); // 읽고 삭제한다.
        return { libraries, templates, tools };
    }
    async exportResources(dest, targets) {
        const [libraries, templates, tools] = await Promise.all([
            sdkService.selectInstalledLibraries(),
            sdkService.selectInstalledTemplates(),
            sdkService.selectInstalledTools(),
        ]);
        const resources = { libraries, templates, tools };
        const types = [SDK_RESOURCE_DIRS.LIBRARY, SDK_RESOURCE_DIRS.TEMPLATE, SDK_RESOURCE_DIRS.TOOL];
        const sources = types.reduce((acc, type) => {
            const _sources = resources[type]
                .filter(({ name }) => targets.includes(name))
                .map(({ filePath }) => {
                const fileName = path.basename(filePath);
                const destPath = ['resources', type, fileName].join('/');
                return [filePath, destPath];
            });
            return [...acc, ..._sources];
        }, []);
        await zip(sources, dest);
    }
}
const sdkService = new SDKService();

export { npmService as n, sdkService as s, unzip as u };
