import * as path from 'path';
import * as os from 'os';
import { l as libExports } from './vendor.DEZAgNuY.js';
import { u as unzip } from './zip.Urfv9crQ.js';
import { B as BaseException, C as CliConfig } from './index.BBihg1b8.js';

class InvalidLicenseException extends BaseException {
    constructor(message) {
        super(message, 'INVALIDE_LICENSE');
        this.message = message;
    }
}
class ClientLicense {
    static async parse(licenseDir) {
        const licFile = path.join(licenseDir, 'mcore.mobile.lic');
        const reducerFactory = (pivot) => {
            return (acc, v) => {
                const [key, value] = v.split(pivot);
                if (key && value)
                    acc[key.trim()] = value.trim();
                return acc;
            };
        };
        if (await libExports.pathExists(licFile)) {
            const content = await libExports.readFile(licFile, { encoding: 'utf-8' });
            const { application_id: appId, expiration_date: expirationDate, namespace_mask } = content.split('\n').reduce(reducerFactory('='), {});
            let packageName = appId;
            let bundleId = appId;
            // v2.5 이하 라이선스에서는 namespace_mask가 없음.
            // appId로 패키지네임, 번들ID로 사용함.
            if (namespace_mask) {
                const { android, ios } = namespace_mask.split(';').reduce(reducerFactory('@'), {});
                if (android)
                    packageName = android;
                if (ios)
                    bundleId = ios;
            }
            if (appId && packageName && bundleId && expirationDate) {
                return new ClientLicense(licenseDir, appId, packageName, bundleId, expirationDate);
            }
            throw new InvalidLicenseException(`${licFile} is invalid.`);
        }
        throw new InvalidLicenseException(`${licFile} is not exists.`);
    }
    constructor(path, appId, packageName, bundleId, expirationDate) {
        this.path = path;
        this.appId = appId;
        this.packageName = packageName;
        this.bundleId = bundleId;
        this.expirationDate = expirationDate;
    }
    get iosLicense() {
        return path.join(this.path, 'ios', 'MCore.license');
    }
    get anroidLicense() {
        return path.join(this.path, 'android'); // directory
    }
    get appLicense() {
        return path.join(this.path, 'mcore.mobile.lic'); // res 폴더에 들어갈 라이선스
    }
    parseExpirationDate(dateString) {
        const [year, month, day] = dateString.split('-').map(Number);
        const date = new Date();
        date.setFullYear(year, month - 1, day);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    get isExpired() {
        const now = Date.now();
        const expireTime = this.parseExpirationDate(this.expirationDate).getTime();
        return expireTime < now;
    }
}

class LicenseService {
    get cliConfig() {
        return CliConfig.getInstance();
    }
    get licenseDir() {
        return path.join(this.cliConfig.dataDir, 'license');
    }
    get eduLicensePath() {
        return path.join(this.cliConfig.embedDir, 'edu_license');
    }
    async getEduLicense(appId) {
        const original = await ClientLicense.parse(this.eduLicensePath);
        if (appId) {
            return new ClientLicense(this.eduLicensePath, original.appId, appId, appId, original.expirationDate);
        }
        return original;
    }
    async loadLicenses() {
        const eduLicense = await this.getEduLicense();
        if (!(await libExports.pathExists(this.licenseDir)))
            return [eduLicense];
        const files = await libExports.readdir(this.licenseDir, { withFileTypes: true });
        const parseTasks = files.filter((file) => file.isDirectory()).map((file) => ClientLicense.parse(path.join(this.licenseDir, file.name)));
        const results = await Promise.allSettled(parseTasks);
        const licenses = results.filter((r) => r.status === 'fulfilled').map(({ value }) => value);
        return [eduLicense, ...licenses];
    }
    async getLicenseByAppId(appId) {
        if (appId.startsWith('mcore.edu.')) {
            return await this.getEduLicense(appId);
        }
        return await ClientLicense.parse(path.join(this.licenseDir, appId));
    }
    async registLicense(zipFile) {
        const tempDir = await libExports.mkdtemp(path.join(os.tmpdir(), 'mcli-'));
        try {
            await unzip(zipFile, path.dirname(tempDir), path.basename(tempDir));
            const license = await ClientLicense.parse(tempDir);
            const dest = path.join(this.licenseDir, license.appId);
            if (await libExports.pathExists(dest))
                await libExports.remove(dest);
            await libExports.copy(tempDir, dest);
        }
        finally {
            await libExports.remove(tempDir);
        }
    }
}
const licenseService = new LicenseService();

export { licenseService as l };
