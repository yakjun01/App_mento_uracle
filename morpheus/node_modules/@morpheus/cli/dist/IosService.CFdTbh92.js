import * as path from 'path';
import { l as libExports, X as XMLParser, B as Builder, p as plistExports } from './vendor.DEZAgNuY.js';
import { C as CliConfig, P as PackageJson, a as BaseJson } from './index.BBihg1b8.js';

class BaseXml {
    constructor(path) {
        this.path = path;
        this.obj = {};
        this.declaration = null;
    }
    async read() {
        const content = await libExports.readFile(this.path, { encoding: 'utf-8' });
        const regex = /<\?xml\s+(.*?)\s*\?>/i;
        const matches = regex.exec(content);
        if (matches && matches[0]) {
            this.declaration = matches[0];
        }
        this.obj = BaseXml.xmlParser.parse(content.replace(regex, '').trim());
    }
    async write(obj) {
        if (obj)
            this.obj = obj;
        const xmlString = BaseXml.xmlBuilder.build(this.obj);
        const content = this.declaration ? `${this.declaration}\n${xmlString}` : xmlString;
        await libExports.writeFile(this.path, content, { encoding: 'utf-8' });
    }
}
BaseXml.xmlParser = new XMLParser({ commentPropName: '#comment', ignoreAttributes: false, ignoreDeclaration: true, attributeNamePrefix: '@_' });
BaseXml.xmlBuilder = new Builder({ commentPropName: '#comment', format: true, ignoreAttributes: false, attributeNamePrefix: '@_' });

class AppManifestXml extends BaseXml {
}

class AndroidStringsXml extends BaseXml {
}

class AndroidService {
    constructor(rootDir) {
        this.rootDir = rootDir;
    }
    async applyAppName(appName) {
        const stringsFilePath = path.join(this.rootDir, 'src', 'main', 'res', 'values', 'strings.xml');
        const stringsXml = new AndroidStringsXml(stringsFilePath);
        await stringsXml.read();
        const exist = stringsXml.obj.resources.string.findIndex((tag) => tag['@_name'] === 'app_name');
        if (exist > -1) {
            stringsXml.obj.resources.string[exist]['#text'] = appName;
            await stringsXml.write();
        }
    }
    async applyAppIcon(icons) {
        const resDir = path.join(this.rootDir, 'src', 'main', 'res');
        await Promise.all(icons.map(async ({ density, imgPath }) => {
            const destDir = path.join(resDir, `drawable-${density}`);
            await libExports.ensureDir(destDir);
            const ext = path.extname(imgPath);
            await libExports.copy(imgPath, path.join(destDir, `icon.${ext}`));
        }));
    }
    async applyLicense(license) {
        const src = license.anroidLicense;
        const dest = path.join(this.rootDir, 'libs');
        const ignore = [path.join(src, 'libMCore.so'), path.join(src, 'mips'), path.join(src, 'mips64')];
        await libExports.ensureDir(dest);
        await libExports.copy(src, dest, {
            filter: (_src) => {
                if (path.basename(_src) === '.DS_Store')
                    return false;
                if (ignore.some((ignore) => _src.startsWith(ignore)))
                    return false;
                return true;
            },
        });
    }
    // only new template..
    async applyPackageName(license, replacer = '%ANDROID_PACKAGE_NAME%') {
        const gradleFile = path.join(this.rootDir, 'build.gradle');
        let gradleContent = await libExports.readFile(gradleFile, { encoding: 'utf-8' });
        gradleContent = gradleContent.replace(new RegExp(replacer, 'g'), license.packageName);
        await libExports.writeFile(gradleFile, gradleContent, { encoding: 'utf-8' });
    }
    async syncLibraries(libraries) {
        const gradleFile = path.join(this.rootDir, 'morpheus.gradle');
        const lines = await Promise.all(libraries.map(async (src) => {
            const targetPath = path.join(src, 'android', 'library.gradle');
            const exist = await libExports.pathExists(targetPath);
            return exist ? `apply from: '${path.relative(this.rootDir, targetPath).replace(/\\/g, '/')}'\n` : '';
        }));
        const content = `// !! DO NOT TOUCH THIS FILE\n${lines.join('')}`;
        await libExports.writeFile(gradleFile, content, { encoding: 'utf-8' });
    }
}

function promisifyStream(ws, rs) {
    return new Promise((resolve, reject) => {
        rs.pipe(ws, { end: false }); // ws 종료는 수동으로 처리
        rs.on('error', reject);
        ws.on('error', reject);
        rs.on('end', resolve);
    });
}

class AssetService {
    constructor(rootDir) {
        this.rootDir = rootDir;
    }
    get cliConfig() {
        return CliConfig.getInstance();
    }
    get manifestFile() {
        return path.join(this.rootDir, 'res', 'Manifest.xml');
    }
    async applyAppStartPage(startPage) {
        const appManifestXml = new AppManifestXml(this.manifestFile);
        await appManifestXml.read();
        appManifestXml.obj.manifest.startpage.name = startPage;
        await appManifestXml.write();
    }
    async applyAppLicense(license) {
        const src = license.appLicense;
        const dest = path.join(this.rootDir, 'res', path.basename(src));
        await libExports.copy(src, dest);
    }
    async syncLegacyWebLibraries(libraries, outputDir) {
        const targetFile = path.join(outputDir, 'mcore.min.js');
        await libExports.ensureDir(outputDir);
        const ws = libExports.createWriteStream(targetFile, { encoding: 'utf-8' });
        try {
            for (const src of libraries) {
                const srcFile = path.join(src, 'legacy', 'index.js');
                if (await libExports.pathExists(srcFile)) {
                    await promisifyStream(ws, libExports.createReadStream(srcFile, { encoding: 'utf-8' }));
                    ws.write('\n'); // 파일 간 구분을 위해 개행 추가
                }
                if (path.basename(src) === 'core') {
                    const wnInterfaceFile = path.join(src, 'legacy', 'wnInterface.js');
                    if (await libExports.pathExists(wnInterfaceFile)) {
                        await libExports.copy(wnInterfaceFile, path.join(outputDir, 'wnInterface.js'));
                    }
                }
            }
        }
        finally {
            ws.end();
        }
    }
    async syncManifestLibraries(libraries, manifestExt) {
        const appManifestXml = new AppManifestXml(this.manifestFile);
        const packageJsons = await Promise.all(libraries.map(async (src) => {
            const targetFile = path.join(src, 'package.json');
            if (await libExports.pathExists(targetFile)) {
                const packageJson = new PackageJson(targetFile);
                await packageJson.read();
                return { ...packageJson.json };
            }
            return {};
        }));
        const { addons, plugins } = packageJsons.reduce((acc, v) => {
            if (v.morpheus && v.morpheus.interface && v.name) {
                const [, name] = v.name.split('/');
                if (name.startsWith('addon-')) {
                    acc.addons.push(v.morpheus.interface);
                }
                else {
                    acc.plugins.push(v.morpheus.interface);
                }
            }
            return acc;
        }, { addons: [], plugins: [] });
        await appManifestXml.read();
        appManifestXml.obj.manifest.library.ext = manifestExt;
        appManifestXml.obj.manifest.library.addons = { path: addons };
        appManifestXml.obj.manifest.library.plugins = { path: plugins };
        await appManifestXml.write();
    }
}

class IosService {
    constructor(rootDir) {
        this.rootDir = rootDir;
    }
    async applyProjectName(projectName) {
        const xcodeprojDir = `${projectName}.xcodeproj`;
        await libExports.rename(path.join(this.rootDir, '[PROJECT_NAME].xcodeproj'), path.join(this.rootDir, xcodeprojDir));
        const reg = /%PROJECT_NAME%/g;
        const podfile = path.join(this.rootDir, 'Podfile');
        let podfileContent = await libExports.readFile(podfile, { encoding: 'utf-8' });
        podfileContent = podfileContent.replace(reg, projectName);
        await libExports.writeFile(podfile, podfileContent, { encoding: 'utf-8' });
        const pbxproj = path.join(this.rootDir, xcodeprojDir, 'project.pbxproj');
        let pbxprojContent = await libExports.readFile(pbxproj, { encoding: 'utf-8' });
        pbxprojContent = pbxprojContent.replace(reg, projectName);
        await libExports.writeFile(pbxproj, pbxprojContent, { encoding: 'utf-8' });
    }
    async applyAppName(appName) {
        const infoPlistPath = path.join(this.rootDir, 'Supporting Files', 'Info.plist');
        const plistContent = await libExports.readFile(infoPlistPath, { encoding: 'utf-8' });
        const info = plistExports.parse(plistContent);
        info.CFBundleDisplayName = appName;
        await libExports.writeFile(infoPlistPath, plistExports.build(info), { encoding: 'utf-8' });
    }
    async applyAppIcon(imgPath) {
        const assetDir = path.join(this.rootDir, 'Supporting Files', 'Assets.xcassets', 'AppIcon.appiconset');
        const ext = path.extname(imgPath);
        const iconFileName = 'icon' + ext;
        const targetFile = path.join(assetDir, 'Contents.json');
        const contentsJson = new BaseJson(targetFile);
        await libExports.ensureDir(assetDir);
        await libExports.copy(imgPath, path.join(assetDir, iconFileName));
        if (await libExports.pathExists(targetFile))
            await contentsJson.read();
        await contentsJson.write({
            ...contentsJson.json,
            images: [
                {
                    filename: iconFileName,
                    idiom: 'universal',
                    platform: 'ios',
                    size: '1024x1024',
                },
            ],
            info: {
                author: 'xcode',
                version: 1,
            },
        });
    }
    async applyLicense(license) {
        const src = license.iosLicense;
        const dest = path.join(this.rootDir, path.basename(src));
        await libExports.copy(src, dest);
    }
    async applyBundleId(license, projectName, replacer = '%BUNDLE_IDENTIFIER%') {
        const xcodeproj = path.join(this.rootDir, `${projectName}.xcodeproj`);
        if (!(await libExports.pathExists(xcodeproj)))
            return; // TODO : 없는 경우 로깅만, 에러는 발생시키지 않는다.
        const pbxprojFile = path.join(xcodeproj, 'project.pbxproj');
        let pbxprojContent = await libExports.readFile(pbxprojFile, { encoding: 'utf-8' });
        pbxprojContent = pbxprojContent.replace(new RegExp(replacer, 'g'), license.bundleId);
        await libExports.writeFile(pbxprojFile, pbxprojContent, { encoding: 'utf-8' });
    }
    async syncLibraries(libraries) {
        const podFile = path.join(this.rootDir, 'Podfile');
        const lines = await Promise.all(libraries.map(async (src) => {
            const iosDir = path.join(src, 'ios');
            const exist = await libExports.pathExists(iosDir);
            if (!exist)
                return '';
            const files = await libExports.readdir(iosDir, { withFileTypes: true });
            const podSpec = files.find((f) => f.isFile() && path.extname(f.name) === '.podspec');
            if (!podSpec)
                return '';
            const podName = path.parse(podSpec.name).name;
            const relativePath = path.relative(this.rootDir, iosDir).replace(/\\\\/g, '/');
            return `  pod '${podName}', :path => '${relativePath}'\n`;
        }));
        let content = '';
        if (await libExports.pathExists(podFile)) {
            content = await libExports.readFile(podFile, { encoding: 'utf-8' });
        }
        const injectContent = `def morpheus_pods\n${lines.join('')}end`;
        const regex = /def\smorpheus_pods[\S\s]*?\nend/;
        content = regex.test(content) ? content.replace(regex, injectContent) : content + '\n' + injectContent;
        await libExports.writeFile(podFile, content, { encoding: 'utf-8' });
    }
}

export { AssetService as A, IosService as I, AndroidService as a };
